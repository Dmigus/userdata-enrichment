# Основные компоненты

Необходимо реализовать сервис, который будет по ФИО обогащать данными и сохранять в БД.

Сервис должен быть реализован на Golang, в качестве БД необходимо использовать PostgreSQL.

Первые три rest метода предполагают выборку и изменение данных в БД. Четвёртый метод сложнее, так как предполагает предварительное обогащение из сторонних сервисов. Рассмотрим варианты его реализации.

Синхронный. 
Клиент отправляет запрос добавления нового человека на сервис. Сервис отправляет запросы на сторонние для обогащения. После получения ответов от сторонних сервис сохраняет данные в БД и возвращает ответ клиенту.
В таком случае единственная проблема сожет быть то, что мы ничего не знаем о пропускной способности сторонних сервисов и наши клиенты могут столкнуться с ошибками из-за <span style="background-color:red">нескоординированного потока запросов от них</span>. Этот вариант мы реализовывать не будем.

Асинхронный.
Клиент отправляет запрос добавления нового человека на сервис. Сервис(bff) сохраняет запрос в БД и очередь и немедленно возвращает пустой ответ клиенту. Другой (микро)сервис вычитывает из очереди по одному, обогащает данные из других систем, а затем обновляет эту запись в БД. В этом случае клиенту не предоставляются гарантии того, когда обогащённые данные появятся в БД.
Этот вариант мы реализуем. 


# REST API
Разработаем api для использования сервиса клиентами. 
В тексте задания есть такие понятия как "люди", "сущности", "сообщения", "данные" и "идентификаторы". 
Мы в дальнейшем будем оперировать _сущностью_ - запись из полей (name, surname, patronymic, age, sex, nationality) и её _идентификатором_ - тройкой полей (name, surname, patronymic).

Следующий набор методов кажется удачным:
- Для получения данных с фильтрами и пагинацией ```GET /records?name=...&surname=...&patronymic=...&age=...&sex=...&nationality=...&limit=...&before=...&after...```
- Для удаления по идентификатору ```DELETE /record/{id}```
- Для изменения сущности ```POST /record/{id}``` + тело с полями и значениями, которые необходимо обновить
- Для создания новой сущности ```PUT /record/{id}``` с пустым телом

Однако в случае метода с добавлением в Задании явно указан json формат, что подразумевает указание id в теле запроса, а не в URI. Скорректируем наши методы, чтобы удовлетворять этому условию.
- Для получения данных с фильтрами и пагинацией ```GET /records?name=...&surname=...&patronymic=...&age=...&sex=...&nationality=...&limit=...&before=...&after...```
- Для удаления по идентификатору ```POST /records/delete``` + тело с ключом
- Для изменения сущности ```POST /records/update``` + тело с ключом и полями со значениями, которые необходимо обновить
- Для создания новой сущности ```POST /records/create``` + тело с ключом

# Архитектура backend сервиса/-ов
"Чистая архитектура" предполагает разбивать модули на слои и организовывать зависимости от наиболее часто изменяющихся модулей к наименее часто изменяющимся.

Слой с вариантами использования (use cases) содержит функциональность для 
- сохранения, получения и удаления текущих записей. Оперирует хранилищем ключ-значение с возможностью фильтрации и пагинации
- создания новой записи и планирования её обогащения. Оперирует очередью для временного хранения запросов 
- обогащения записи информацией о возрасте, поле, национальности

Модуль с БД содержит реализацию использования postgresql в качестве хранилища записей.

Модуль с брокером содержит реализацию использования kafka с одной очередью и одной партицией.

Модуль с обогатителями содержит контроллеры для обогащения данных по http из других сервисов.

# Хранилище
## БД
Можно составить из одной таблицы records, содержащую все упомянутые поля, а также служебные.
Для быстрого доступа по ключу добавим индекс по ключевым полям. 
